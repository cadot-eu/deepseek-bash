#!/bin/bash

# Charger le token depuis le fichier caché
source ~/.deepseek_bash

# Vérifier que le token est présent
if [ -z "$DEEPSEEK_API_TOKEN" ]; then
  echo "Token API DeepSeek manquant dans ~/.deepseek_bash"
  exit 1
fi

is_bash_script() {
  [[ "$1" =~ ^#!\/bin\/bash ]] && return 0 || return 1
}

# Vérifier les options -c/--confirmation, -d/--debug, -s/--save et -p/--push
CONFIRM=false
DEBUG=false
SAVE=false
SAVE_PATH=""
PUSH_FILES=()
while [[ "$1" =~ ^- ]]; do
  case "$1" in
    -c|--confirmation)
      CONFIRM=true
      shift
      ;;
    -d|--debug)
      DEBUG=true
      shift
      ;;
    -s|--save)
      SAVE=true
      SAVE_PATH="$2"
      shift 2
      ;;
    -p|--push)
      PUSH_FILES+=("$2")
      shift 2
      ;;
    *)
      break
      ;;
  esac
done

# Récupérer les HISTORY dernières commandes du bash

# Récupérer et échapper les HISTORY dernières commandes du bash
HIST_COUNT=${HISTORY:-10}
BASH_HISTORY_RAW=$(tail -n "$HIST_COUNT" ~/.bash_history | awk '{print NR ": " $0}')
BASH_HISTORY=$(printf '%s' "$BASH_HISTORY_RAW" | python3 -c 'import json,sys; print(json.dumps(sys.stdin.read())[1:-1])')

# Ajouter le contenu des fichiers push à la question
PUSH_CONTENT=""
for f in "${PUSH_FILES[@]}"; do
  if [ -f "$f" ]; then
    FILE_TEXT=$(cat "$f")
    PUSH_CONTENT+="\n\n--- File: $f ---\n$FILE_TEXT"
  else
    PUSH_CONTENT+="\n\n--- File: $f not found ---"
  fi
done

# Construire la requête à partir des arguments
PROMPT="$*"
if [ -n "$PUSH_CONTENT" ]; then
  PROMPT="$PUSH_CONTENT\n\n$PROMPT"
fi

# Appeler l'API DeepSeek
# (supprimé pour une sortie plus propre)


# Échapper correctement le prompt pour le JSON
ESCAPED_PROMPT=$(printf '%s' "$PROMPT" | python3 -c 'import json,sys; print(json.dumps(sys.stdin.read())[1:-1])')

JSON_PAYLOAD=$(cat <<EOF
{
  "model": "deepseek-chat",
  "messages": [
    {"role": "system", "content": "You are a helpful assistant. You only answer with a bash command, no explanation. If you return a command, always start with #!/bin/bash."},
    {"role": "user", "content": "Historique des commandes précédentes :\n$BASH_HISTORY\n\nQuestion : $ESCAPED_PROMPT"}
  ],
  "stream": false
}
EOF
)

RESPONSE=$(curl -s -X POST "https://api.deepseek.com/chat/completions" \
  -H "Authorization: Bearer $DEEPSEEK_API_TOKEN" \
  -H "Content-Type: application/json" \
  -d "$JSON_PAYLOAD")

# Afficher la réponse brute pour debug
# (supprimé pour une sortie plus propre)
# Extraire la commande générée (champ assistant, JSON imbriqué)
COMMAND=$(echo "$RESPONSE" | python3 -c "import sys, json; r=json.load(sys.stdin); print(r['choices'][0]['message']['content']) if 'choices' in r and r['choices'] else print('')")

if [ -z "$COMMAND" ]; then
  ERROR_MSG=$(echo "$RESPONSE" | grep -oP '"error_msg"\s*:\s*"\K[^"}]+')
  if [ -n "$ERROR_MSG" ]; then
    echo "Erreur API DeepSeek: $ERROR_MSG"
  else
    echo "Erreur: aucune commande générée. Réponse: $RESPONSE"
  fi
  exit 2
fi

# (supprimé pour une sortie plus propre)


# Afficher la commande avant exécution ou debug
echo "----------------------------------------"
if is_bash_script "$COMMAND"; then
  # Supprime le shebang et les lignes vides
  CMD_MAIN=$(echo "$COMMAND" | sed '1{/^#!\/bin\/bash$/d}' | sed '/^$/d' | tail -n 1)
  bash -c "$CMD_MAIN" 2>&1
else
  echo "$COMMAND"
fi
if [ "$DEBUG" = true ]; then
  echo -e "\n--- DEBUG ---"
  echo -e "\033[1;34mQuestion envoyée à DeepSeek :\033[0m"
  echo -e "\033[1;34mHistorique des commandes précédentes :\033[0m"
  tail -n "${HISTORY:-10}" ~/.bash_history | awk '{print NR ": " $0}'
  echo -e "\n\033[1;34mQuestion :\033[0m $*"
  echo -e "\n\033[1;34mJSON envoyé :\033[0m"
  echo "$JSON_PAYLOAD"
  echo -e "\n\033[1;34mRéponse JSON DeepSeek :\033[0m"
  echo "$RESPONSE"
  echo -e "\n\033[1;32mCommande proposée par Deepseek :\033[0m"
  echo "$COMMAND"
  echo "--- FIN DEBUG ---"
  exit 0
fi
if [ "$SAVE" = true ]; then
  if [ -z "$SAVE_PATH" ]; then
    echo "Erreur : chemin de fichier manquant pour l'option -s/--save."
    exit 3
  fi
  bash -c "$COMMAND" > "$SAVE_PATH"
  echo "Résultat de la commande sauvegardé dans : $SAVE_PATH"
  exit 0
fi

# Toute la logique de confirmation/exécution ne regarde que le shebang
